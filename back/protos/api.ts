// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.17.3
// source: back/protos/api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "com.ql.api";

export interface EnvItem {
  id?: number | undefined;
  name?: string | undefined;
  value?: string | undefined;
  remarks?: string | undefined;
  status?: number | undefined;
  position?: number | undefined;
}

export interface GetEnvsRequest {
  searchValue: string;
}

export interface CreateEnvRequest {
  envs: EnvItem[];
}

export interface UpdateEnvRequest {
  env: EnvItem | undefined;
}

export interface DeleteEnvsRequest {
  ids: number[];
}

export interface MoveEnvRequest {
  id: number;
  fromIndex: number;
  toIndex: number;
}

export interface DisableEnvsRequest {
  ids: number[];
}

export interface EnableEnvsRequest {
  ids: number[];
}

export interface UpdateEnvNamesRequest {
  ids: number[];
  name: string;
}

export interface GetEnvByIdRequest {
  id: number;
}

export interface EnvsResponse {
  code: number;
  data: EnvItem[];
  message?: string | undefined;
}

export interface EnvResponse {
  code: number;
  data: EnvItem | undefined;
  message?: string | undefined;
}

export interface Response {
  code: number;
  message?: string | undefined;
}

export interface SystemNotifyRequest {
  title: string;
  content: string;
}

export interface ExtraScheduleItem {
  schedule: string;
}

export interface CronItem {
  id?: number | undefined;
  command?: string | undefined;
  schedule?: string | undefined;
  name?: string | undefined;
  labels: string[];
  sub_id?: number | undefined;
  extra_schedules: ExtraScheduleItem[];
  task_before?: string | undefined;
  task_after?: string | undefined;
  status?: number | undefined;
  log_path?: string | undefined;
  pid?: number | undefined;
  last_running_time?: number | undefined;
  last_execution_time?: number | undefined;
}

export interface CreateCronRequest {
  command: string;
  schedule: string;
  name?: string | undefined;
  labels: string[];
  sub_id?: number | undefined;
  extra_schedules: ExtraScheduleItem[];
  task_before?: string | undefined;
  task_after?: string | undefined;
}

export interface UpdateCronRequest {
  id: number;
  command?: string | undefined;
  schedule?: string | undefined;
  name?: string | undefined;
  labels: string[];
  sub_id?: number | undefined;
  extra_schedules: ExtraScheduleItem[];
  task_before?: string | undefined;
  task_after?: string | undefined;
}

export interface DeleteCronsRequest {
  ids: number[];
}

export interface CronsResponse {
  code: number;
  data: CronItem[];
  message?: string | undefined;
}

export interface CronResponse {
  code: number;
  data: CronItem | undefined;
  message?: string | undefined;
}

export interface CronDetailRequest {
  log_path: string;
}

export interface CronDetailResponse {
  code: number;
  data: CronItem | undefined;
  message?: string | undefined;
}

function createBaseEnvItem(): EnvItem {
  return {
    id: undefined,
    name: undefined,
    value: undefined,
    remarks: undefined,
    status: undefined,
    position: undefined,
  };
}

export const EnvItem: MessageFns<EnvItem> = {
  encode(message: EnvItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== undefined) {
      writer.uint32(26).string(message.value);
    }
    if (message.remarks !== undefined) {
      writer.uint32(34).string(message.remarks);
    }
    if (message.status !== undefined) {
      writer.uint32(40).int32(message.status);
    }
    if (message.position !== undefined) {
      writer.uint32(48).int64(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remarks = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.position = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvItem {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      remarks: isSet(object.remarks) ? globalThis.String(object.remarks) : undefined,
      status: isSet(object.status) ? globalThis.Number(object.status) : undefined,
      position: isSet(object.position) ? globalThis.Number(object.position) : undefined,
    };
  },

  toJSON(message: EnvItem): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.remarks !== undefined) {
      obj.remarks = message.remarks;
    }
    if (message.status !== undefined) {
      obj.status = Math.round(message.status);
    }
    if (message.position !== undefined) {
      obj.position = Math.round(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvItem>, I>>(base?: I): EnvItem {
    return EnvItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvItem>, I>>(object: I): EnvItem {
    const message = createBaseEnvItem();
    message.id = object.id ?? undefined;
    message.name = object.name ?? undefined;
    message.value = object.value ?? undefined;
    message.remarks = object.remarks ?? undefined;
    message.status = object.status ?? undefined;
    message.position = object.position ?? undefined;
    return message;
  },
};

function createBaseGetEnvsRequest(): GetEnvsRequest {
  return { searchValue: "" };
}

export const GetEnvsRequest: MessageFns<GetEnvsRequest> = {
  encode(message: GetEnvsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchValue !== "") {
      writer.uint32(10).string(message.searchValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnvsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnvsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEnvsRequest {
    return { searchValue: isSet(object.searchValue) ? globalThis.String(object.searchValue) : "" };
  },

  toJSON(message: GetEnvsRequest): unknown {
    const obj: any = {};
    if (message.searchValue !== "") {
      obj.searchValue = message.searchValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEnvsRequest>, I>>(base?: I): GetEnvsRequest {
    return GetEnvsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEnvsRequest>, I>>(object: I): GetEnvsRequest {
    const message = createBaseGetEnvsRequest();
    message.searchValue = object.searchValue ?? "";
    return message;
  },
};

function createBaseCreateEnvRequest(): CreateEnvRequest {
  return { envs: [] };
}

export const CreateEnvRequest: MessageFns<CreateEnvRequest> = {
  encode(message: CreateEnvRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.envs) {
      EnvItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEnvRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEnvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.envs.push(EnvItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEnvRequest {
    return { envs: globalThis.Array.isArray(object?.envs) ? object.envs.map((e: any) => EnvItem.fromJSON(e)) : [] };
  },

  toJSON(message: CreateEnvRequest): unknown {
    const obj: any = {};
    if (message.envs?.length) {
      obj.envs = message.envs.map((e) => EnvItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateEnvRequest>, I>>(base?: I): CreateEnvRequest {
    return CreateEnvRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateEnvRequest>, I>>(object: I): CreateEnvRequest {
    const message = createBaseCreateEnvRequest();
    message.envs = object.envs?.map((e) => EnvItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateEnvRequest(): UpdateEnvRequest {
  return { env: undefined };
}

export const UpdateEnvRequest: MessageFns<UpdateEnvRequest> = {
  encode(message: UpdateEnvRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.env !== undefined) {
      EnvItem.encode(message.env, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEnvRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEnvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.env = EnvItem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEnvRequest {
    return { env: isSet(object.env) ? EnvItem.fromJSON(object.env) : undefined };
  },

  toJSON(message: UpdateEnvRequest): unknown {
    const obj: any = {};
    if (message.env !== undefined) {
      obj.env = EnvItem.toJSON(message.env);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateEnvRequest>, I>>(base?: I): UpdateEnvRequest {
    return UpdateEnvRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateEnvRequest>, I>>(object: I): UpdateEnvRequest {
    const message = createBaseUpdateEnvRequest();
    message.env = (object.env !== undefined && object.env !== null) ? EnvItem.fromPartial(object.env) : undefined;
    return message;
  },
};

function createBaseDeleteEnvsRequest(): DeleteEnvsRequest {
  return { ids: [] };
}

export const DeleteEnvsRequest: MessageFns<DeleteEnvsRequest> = {
  encode(message: DeleteEnvsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEnvsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEnvsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ids.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEnvsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: DeleteEnvsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteEnvsRequest>, I>>(base?: I): DeleteEnvsRequest {
    return DeleteEnvsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteEnvsRequest>, I>>(object: I): DeleteEnvsRequest {
    const message = createBaseDeleteEnvsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseMoveEnvRequest(): MoveEnvRequest {
  return { id: 0, fromIndex: 0, toIndex: 0 };
}

export const MoveEnvRequest: MessageFns<MoveEnvRequest> = {
  encode(message: MoveEnvRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.fromIndex !== 0) {
      writer.uint32(16).int32(message.fromIndex);
    }
    if (message.toIndex !== 0) {
      writer.uint32(24).int32(message.toIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveEnvRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveEnvRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromIndex = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.toIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveEnvRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      fromIndex: isSet(object.fromIndex) ? globalThis.Number(object.fromIndex) : 0,
      toIndex: isSet(object.toIndex) ? globalThis.Number(object.toIndex) : 0,
    };
  },

  toJSON(message: MoveEnvRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.fromIndex !== 0) {
      obj.fromIndex = Math.round(message.fromIndex);
    }
    if (message.toIndex !== 0) {
      obj.toIndex = Math.round(message.toIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoveEnvRequest>, I>>(base?: I): MoveEnvRequest {
    return MoveEnvRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoveEnvRequest>, I>>(object: I): MoveEnvRequest {
    const message = createBaseMoveEnvRequest();
    message.id = object.id ?? 0;
    message.fromIndex = object.fromIndex ?? 0;
    message.toIndex = object.toIndex ?? 0;
    return message;
  },
};

function createBaseDisableEnvsRequest(): DisableEnvsRequest {
  return { ids: [] };
}

export const DisableEnvsRequest: MessageFns<DisableEnvsRequest> = {
  encode(message: DisableEnvsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisableEnvsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisableEnvsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ids.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisableEnvsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: DisableEnvsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisableEnvsRequest>, I>>(base?: I): DisableEnvsRequest {
    return DisableEnvsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisableEnvsRequest>, I>>(object: I): DisableEnvsRequest {
    const message = createBaseDisableEnvsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseEnableEnvsRequest(): EnableEnvsRequest {
  return { ids: [] };
}

export const EnableEnvsRequest: MessageFns<EnableEnvsRequest> = {
  encode(message: EnableEnvsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableEnvsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableEnvsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ids.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnableEnvsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: EnableEnvsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnableEnvsRequest>, I>>(base?: I): EnableEnvsRequest {
    return EnableEnvsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnableEnvsRequest>, I>>(object: I): EnableEnvsRequest {
    const message = createBaseEnableEnvsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateEnvNamesRequest(): UpdateEnvNamesRequest {
  return { ids: [], name: "" };
}

export const UpdateEnvNamesRequest: MessageFns<UpdateEnvNamesRequest> = {
  encode(message: UpdateEnvNamesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.int32(v);
    }
    writer.join();
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEnvNamesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEnvNamesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ids.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEnvNamesRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UpdateEnvNamesRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateEnvNamesRequest>, I>>(base?: I): UpdateEnvNamesRequest {
    return UpdateEnvNamesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateEnvNamesRequest>, I>>(object: I): UpdateEnvNamesRequest {
    const message = createBaseUpdateEnvNamesRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetEnvByIdRequest(): GetEnvByIdRequest {
  return { id: 0 };
}

export const GetEnvByIdRequest: MessageFns<GetEnvByIdRequest> = {
  encode(message: GetEnvByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEnvByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEnvByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEnvByIdRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetEnvByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEnvByIdRequest>, I>>(base?: I): GetEnvByIdRequest {
    return GetEnvByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEnvByIdRequest>, I>>(object: I): GetEnvByIdRequest {
    const message = createBaseGetEnvByIdRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseEnvsResponse(): EnvsResponse {
  return { code: 0, data: [], message: undefined };
}

export const EnvsResponse: MessageFns<EnvsResponse> = {
  encode(message: EnvsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    for (const v of message.data) {
      EnvItem.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(EnvItem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvsResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => EnvItem.fromJSON(e)) : [],
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: EnvsResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => EnvItem.toJSON(e));
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvsResponse>, I>>(base?: I): EnvsResponse {
    return EnvsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvsResponse>, I>>(object: I): EnvsResponse {
    const message = createBaseEnvsResponse();
    message.code = object.code ?? 0;
    message.data = object.data?.map((e) => EnvItem.fromPartial(e)) || [];
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseEnvResponse(): EnvResponse {
  return { code: 0, data: undefined, message: undefined };
}

export const EnvResponse: MessageFns<EnvResponse> = {
  encode(message: EnvResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.data !== undefined) {
      EnvItem.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = EnvItem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      data: isSet(object.data) ? EnvItem.fromJSON(object.data) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: EnvResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.data !== undefined) {
      obj.data = EnvItem.toJSON(message.data);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvResponse>, I>>(base?: I): EnvResponse {
    return EnvResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvResponse>, I>>(object: I): EnvResponse {
    const message = createBaseEnvResponse();
    message.code = object.code ?? 0;
    message.data = (object.data !== undefined && object.data !== null) ? EnvItem.fromPartial(object.data) : undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseResponse(): Response {
  return { code: 0, message: undefined };
}

export const Response: MessageFns<Response> = {
  encode(message: Response, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== undefined) {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Response {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Response {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: Response): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response>, I>>(base?: I): Response {
    return Response.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response>, I>>(object: I): Response {
    const message = createBaseResponse();
    message.code = object.code ?? 0;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseSystemNotifyRequest(): SystemNotifyRequest {
  return { title: "", content: "" };
}

export const SystemNotifyRequest: MessageFns<SystemNotifyRequest> = {
  encode(message: SystemNotifyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemNotifyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemNotifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemNotifyRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: SystemNotifyRequest): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemNotifyRequest>, I>>(base?: I): SystemNotifyRequest {
    return SystemNotifyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemNotifyRequest>, I>>(object: I): SystemNotifyRequest {
    const message = createBaseSystemNotifyRequest();
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseExtraScheduleItem(): ExtraScheduleItem {
  return { schedule: "" };
}

export const ExtraScheduleItem: MessageFns<ExtraScheduleItem> = {
  encode(message: ExtraScheduleItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schedule !== "") {
      writer.uint32(10).string(message.schedule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtraScheduleItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtraScheduleItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtraScheduleItem {
    return { schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "" };
  },

  toJSON(message: ExtraScheduleItem): unknown {
    const obj: any = {};
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExtraScheduleItem>, I>>(base?: I): ExtraScheduleItem {
    return ExtraScheduleItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExtraScheduleItem>, I>>(object: I): ExtraScheduleItem {
    const message = createBaseExtraScheduleItem();
    message.schedule = object.schedule ?? "";
    return message;
  },
};

function createBaseCronItem(): CronItem {
  return {
    id: undefined,
    command: undefined,
    schedule: undefined,
    name: undefined,
    labels: [],
    sub_id: undefined,
    extra_schedules: [],
    task_before: undefined,
    task_after: undefined,
    status: undefined,
    log_path: undefined,
    pid: undefined,
    last_running_time: undefined,
    last_execution_time: undefined,
  };
}

export const CronItem: MessageFns<CronItem> = {
  encode(message: CronItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(8).int32(message.id);
    }
    if (message.command !== undefined) {
      writer.uint32(18).string(message.command);
    }
    if (message.schedule !== undefined) {
      writer.uint32(26).string(message.schedule);
    }
    if (message.name !== undefined) {
      writer.uint32(34).string(message.name);
    }
    for (const v of message.labels) {
      writer.uint32(42).string(v!);
    }
    if (message.sub_id !== undefined) {
      writer.uint32(48).int32(message.sub_id);
    }
    for (const v of message.extra_schedules) {
      ExtraScheduleItem.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.task_before !== undefined) {
      writer.uint32(66).string(message.task_before);
    }
    if (message.task_after !== undefined) {
      writer.uint32(74).string(message.task_after);
    }
    if (message.status !== undefined) {
      writer.uint32(80).int32(message.status);
    }
    if (message.log_path !== undefined) {
      writer.uint32(90).string(message.log_path);
    }
    if (message.pid !== undefined) {
      writer.uint32(96).int32(message.pid);
    }
    if (message.last_running_time !== undefined) {
      writer.uint32(104).int64(message.last_running_time);
    }
    if (message.last_execution_time !== undefined) {
      writer.uint32(112).int64(message.last_execution_time);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sub_id = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.extra_schedules.push(ExtraScheduleItem.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.task_before = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.task_after = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.log_path = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.pid = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.last_running_time = longToNumber(reader.int64());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.last_execution_time = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronItem {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : undefined,
      command: isSet(object.command) ? globalThis.String(object.command) : undefined,
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      sub_id: isSet(object.sub_id) ? globalThis.Number(object.sub_id) : undefined,
      extra_schedules: globalThis.Array.isArray(object?.extra_schedules)
        ? object.extra_schedules.map((e: any) => ExtraScheduleItem.fromJSON(e))
        : [],
      task_before: isSet(object.task_before) ? globalThis.String(object.task_before) : undefined,
      task_after: isSet(object.task_after) ? globalThis.String(object.task_after) : undefined,
      status: isSet(object.status) ? globalThis.Number(object.status) : undefined,
      log_path: isSet(object.log_path) ? globalThis.String(object.log_path) : undefined,
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : undefined,
      last_running_time: isSet(object.last_running_time) ? globalThis.Number(object.last_running_time) : undefined,
      last_execution_time: isSet(object.last_execution_time)
        ? globalThis.Number(object.last_execution_time)
        : undefined,
    };
  },

  toJSON(message: CronItem): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = Math.round(message.id);
    }
    if (message.command !== undefined) {
      obj.command = message.command;
    }
    if (message.schedule !== undefined) {
      obj.schedule = message.schedule;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.sub_id !== undefined) {
      obj.sub_id = Math.round(message.sub_id);
    }
    if (message.extra_schedules?.length) {
      obj.extra_schedules = message.extra_schedules.map((e) => ExtraScheduleItem.toJSON(e));
    }
    if (message.task_before !== undefined) {
      obj.task_before = message.task_before;
    }
    if (message.task_after !== undefined) {
      obj.task_after = message.task_after;
    }
    if (message.status !== undefined) {
      obj.status = Math.round(message.status);
    }
    if (message.log_path !== undefined) {
      obj.log_path = message.log_path;
    }
    if (message.pid !== undefined) {
      obj.pid = Math.round(message.pid);
    }
    if (message.last_running_time !== undefined) {
      obj.last_running_time = Math.round(message.last_running_time);
    }
    if (message.last_execution_time !== undefined) {
      obj.last_execution_time = Math.round(message.last_execution_time);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronItem>, I>>(base?: I): CronItem {
    return CronItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronItem>, I>>(object: I): CronItem {
    const message = createBaseCronItem();
    message.id = object.id ?? undefined;
    message.command = object.command ?? undefined;
    message.schedule = object.schedule ?? undefined;
    message.name = object.name ?? undefined;
    message.labels = object.labels?.map((e) => e) || [];
    message.sub_id = object.sub_id ?? undefined;
    message.extra_schedules = object.extra_schedules?.map((e) => ExtraScheduleItem.fromPartial(e)) || [];
    message.task_before = object.task_before ?? undefined;
    message.task_after = object.task_after ?? undefined;
    message.status = object.status ?? undefined;
    message.log_path = object.log_path ?? undefined;
    message.pid = object.pid ?? undefined;
    message.last_running_time = object.last_running_time ?? undefined;
    message.last_execution_time = object.last_execution_time ?? undefined;
    return message;
  },
};

function createBaseCreateCronRequest(): CreateCronRequest {
  return {
    command: "",
    schedule: "",
    name: undefined,
    labels: [],
    sub_id: undefined,
    extra_schedules: [],
    task_before: undefined,
    task_after: undefined,
  };
}

export const CreateCronRequest: MessageFns<CreateCronRequest> = {
  encode(message: CreateCronRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.schedule !== "") {
      writer.uint32(18).string(message.schedule);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.labels) {
      writer.uint32(34).string(v!);
    }
    if (message.sub_id !== undefined) {
      writer.uint32(40).int32(message.sub_id);
    }
    for (const v of message.extra_schedules) {
      ExtraScheduleItem.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.task_before !== undefined) {
      writer.uint32(58).string(message.task_before);
    }
    if (message.task_after !== undefined) {
      writer.uint32(66).string(message.task_after);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCronRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCronRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sub_id = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.extra_schedules.push(ExtraScheduleItem.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.task_before = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.task_after = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCronRequest {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      sub_id: isSet(object.sub_id) ? globalThis.Number(object.sub_id) : undefined,
      extra_schedules: globalThis.Array.isArray(object?.extra_schedules)
        ? object.extra_schedules.map((e: any) => ExtraScheduleItem.fromJSON(e))
        : [],
      task_before: isSet(object.task_before) ? globalThis.String(object.task_before) : undefined,
      task_after: isSet(object.task_after) ? globalThis.String(object.task_after) : undefined,
    };
  },

  toJSON(message: CreateCronRequest): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.sub_id !== undefined) {
      obj.sub_id = Math.round(message.sub_id);
    }
    if (message.extra_schedules?.length) {
      obj.extra_schedules = message.extra_schedules.map((e) => ExtraScheduleItem.toJSON(e));
    }
    if (message.task_before !== undefined) {
      obj.task_before = message.task_before;
    }
    if (message.task_after !== undefined) {
      obj.task_after = message.task_after;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCronRequest>, I>>(base?: I): CreateCronRequest {
    return CreateCronRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCronRequest>, I>>(object: I): CreateCronRequest {
    const message = createBaseCreateCronRequest();
    message.command = object.command ?? "";
    message.schedule = object.schedule ?? "";
    message.name = object.name ?? undefined;
    message.labels = object.labels?.map((e) => e) || [];
    message.sub_id = object.sub_id ?? undefined;
    message.extra_schedules = object.extra_schedules?.map((e) => ExtraScheduleItem.fromPartial(e)) || [];
    message.task_before = object.task_before ?? undefined;
    message.task_after = object.task_after ?? undefined;
    return message;
  },
};

function createBaseUpdateCronRequest(): UpdateCronRequest {
  return {
    id: 0,
    command: undefined,
    schedule: undefined,
    name: undefined,
    labels: [],
    sub_id: undefined,
    extra_schedules: [],
    task_before: undefined,
    task_after: undefined,
  };
}

export const UpdateCronRequest: MessageFns<UpdateCronRequest> = {
  encode(message: UpdateCronRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.command !== undefined) {
      writer.uint32(18).string(message.command);
    }
    if (message.schedule !== undefined) {
      writer.uint32(26).string(message.schedule);
    }
    if (message.name !== undefined) {
      writer.uint32(34).string(message.name);
    }
    for (const v of message.labels) {
      writer.uint32(42).string(v!);
    }
    if (message.sub_id !== undefined) {
      writer.uint32(48).int32(message.sub_id);
    }
    for (const v of message.extra_schedules) {
      ExtraScheduleItem.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.task_before !== undefined) {
      writer.uint32(66).string(message.task_before);
    }
    if (message.task_after !== undefined) {
      writer.uint32(74).string(message.task_after);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCronRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCronRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.labels.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sub_id = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.extra_schedules.push(ExtraScheduleItem.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.task_before = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.task_after = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCronRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      command: isSet(object.command) ? globalThis.String(object.command) : undefined,
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      labels: globalThis.Array.isArray(object?.labels) ? object.labels.map((e: any) => globalThis.String(e)) : [],
      sub_id: isSet(object.sub_id) ? globalThis.Number(object.sub_id) : undefined,
      extra_schedules: globalThis.Array.isArray(object?.extra_schedules)
        ? object.extra_schedules.map((e: any) => ExtraScheduleItem.fromJSON(e))
        : [],
      task_before: isSet(object.task_before) ? globalThis.String(object.task_before) : undefined,
      task_after: isSet(object.task_after) ? globalThis.String(object.task_after) : undefined,
    };
  },

  toJSON(message: UpdateCronRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.command !== undefined) {
      obj.command = message.command;
    }
    if (message.schedule !== undefined) {
      obj.schedule = message.schedule;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.labels?.length) {
      obj.labels = message.labels;
    }
    if (message.sub_id !== undefined) {
      obj.sub_id = Math.round(message.sub_id);
    }
    if (message.extra_schedules?.length) {
      obj.extra_schedules = message.extra_schedules.map((e) => ExtraScheduleItem.toJSON(e));
    }
    if (message.task_before !== undefined) {
      obj.task_before = message.task_before;
    }
    if (message.task_after !== undefined) {
      obj.task_after = message.task_after;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCronRequest>, I>>(base?: I): UpdateCronRequest {
    return UpdateCronRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCronRequest>, I>>(object: I): UpdateCronRequest {
    const message = createBaseUpdateCronRequest();
    message.id = object.id ?? 0;
    message.command = object.command ?? undefined;
    message.schedule = object.schedule ?? undefined;
    message.name = object.name ?? undefined;
    message.labels = object.labels?.map((e) => e) || [];
    message.sub_id = object.sub_id ?? undefined;
    message.extra_schedules = object.extra_schedules?.map((e) => ExtraScheduleItem.fromPartial(e)) || [];
    message.task_before = object.task_before ?? undefined;
    message.task_after = object.task_after ?? undefined;
    return message;
  },
};

function createBaseDeleteCronsRequest(): DeleteCronsRequest {
  return { ids: [] };
}

export const DeleteCronsRequest: MessageFns<DeleteCronsRequest> = {
  encode(message: DeleteCronsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCronsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCronsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ids.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCronsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [] };
  },

  toJSON(message: DeleteCronsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCronsRequest>, I>>(base?: I): DeleteCronsRequest {
    return DeleteCronsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCronsRequest>, I>>(object: I): DeleteCronsRequest {
    const message = createBaseDeleteCronsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseCronsResponse(): CronsResponse {
  return { code: 0, data: [], message: undefined };
}

export const CronsResponse: MessageFns<CronsResponse> = {
  encode(message: CronsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    for (const v of message.data) {
      CronItem.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(CronItem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronsResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => CronItem.fromJSON(e)) : [],
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: CronsResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => CronItem.toJSON(e));
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronsResponse>, I>>(base?: I): CronsResponse {
    return CronsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronsResponse>, I>>(object: I): CronsResponse {
    const message = createBaseCronsResponse();
    message.code = object.code ?? 0;
    message.data = object.data?.map((e) => CronItem.fromPartial(e)) || [];
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseCronResponse(): CronResponse {
  return { code: 0, data: undefined, message: undefined };
}

export const CronResponse: MessageFns<CronResponse> = {
  encode(message: CronResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.data !== undefined) {
      CronItem.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = CronItem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      data: isSet(object.data) ? CronItem.fromJSON(object.data) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: CronResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.data !== undefined) {
      obj.data = CronItem.toJSON(message.data);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronResponse>, I>>(base?: I): CronResponse {
    return CronResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronResponse>, I>>(object: I): CronResponse {
    const message = createBaseCronResponse();
    message.code = object.code ?? 0;
    message.data = (object.data !== undefined && object.data !== null) ? CronItem.fromPartial(object.data) : undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseCronDetailRequest(): CronDetailRequest {
  return { log_path: "" };
}

export const CronDetailRequest: MessageFns<CronDetailRequest> = {
  encode(message: CronDetailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.log_path !== "") {
      writer.uint32(10).string(message.log_path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronDetailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronDetailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.log_path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronDetailRequest {
    return { log_path: isSet(object.log_path) ? globalThis.String(object.log_path) : "" };
  },

  toJSON(message: CronDetailRequest): unknown {
    const obj: any = {};
    if (message.log_path !== "") {
      obj.log_path = message.log_path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronDetailRequest>, I>>(base?: I): CronDetailRequest {
    return CronDetailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronDetailRequest>, I>>(object: I): CronDetailRequest {
    const message = createBaseCronDetailRequest();
    message.log_path = object.log_path ?? "";
    return message;
  },
};

function createBaseCronDetailResponse(): CronDetailResponse {
  return { code: 0, data: undefined, message: undefined };
}

export const CronDetailResponse: MessageFns<CronDetailResponse> = {
  encode(message: CronDetailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.data !== undefined) {
      CronItem.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronDetailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronDetailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = CronItem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronDetailResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      data: isSet(object.data) ? CronItem.fromJSON(object.data) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: CronDetailResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.data !== undefined) {
      obj.data = CronItem.toJSON(message.data);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronDetailResponse>, I>>(base?: I): CronDetailResponse {
    return CronDetailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronDetailResponse>, I>>(object: I): CronDetailResponse {
    const message = createBaseCronDetailResponse();
    message.code = object.code ?? 0;
    message.data = (object.data !== undefined && object.data !== null) ? CronItem.fromPartial(object.data) : undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

export type ApiService = typeof ApiService;
export const ApiService = {
  getEnvs: {
    path: "/com.ql.api.Api/GetEnvs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEnvsRequest) => Buffer.from(GetEnvsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetEnvsRequest.decode(value),
    responseSerialize: (value: EnvsResponse) => Buffer.from(EnvsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EnvsResponse.decode(value),
  },
  createEnv: {
    path: "/com.ql.api.Api/CreateEnv",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateEnvRequest) => Buffer.from(CreateEnvRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateEnvRequest.decode(value),
    responseSerialize: (value: EnvsResponse) => Buffer.from(EnvsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EnvsResponse.decode(value),
  },
  updateEnv: {
    path: "/com.ql.api.Api/UpdateEnv",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateEnvRequest) => Buffer.from(UpdateEnvRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateEnvRequest.decode(value),
    responseSerialize: (value: EnvResponse) => Buffer.from(EnvResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EnvResponse.decode(value),
  },
  deleteEnvs: {
    path: "/com.ql.api.Api/DeleteEnvs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteEnvsRequest) => Buffer.from(DeleteEnvsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteEnvsRequest.decode(value),
    responseSerialize: (value: Response) => Buffer.from(Response.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Response.decode(value),
  },
  moveEnv: {
    path: "/com.ql.api.Api/MoveEnv",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MoveEnvRequest) => Buffer.from(MoveEnvRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MoveEnvRequest.decode(value),
    responseSerialize: (value: EnvResponse) => Buffer.from(EnvResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EnvResponse.decode(value),
  },
  disableEnvs: {
    path: "/com.ql.api.Api/DisableEnvs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DisableEnvsRequest) => Buffer.from(DisableEnvsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DisableEnvsRequest.decode(value),
    responseSerialize: (value: Response) => Buffer.from(Response.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Response.decode(value),
  },
  enableEnvs: {
    path: "/com.ql.api.Api/EnableEnvs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EnableEnvsRequest) => Buffer.from(EnableEnvsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => EnableEnvsRequest.decode(value),
    responseSerialize: (value: Response) => Buffer.from(Response.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Response.decode(value),
  },
  updateEnvNames: {
    path: "/com.ql.api.Api/UpdateEnvNames",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateEnvNamesRequest) => Buffer.from(UpdateEnvNamesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateEnvNamesRequest.decode(value),
    responseSerialize: (value: Response) => Buffer.from(Response.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Response.decode(value),
  },
  getEnvById: {
    path: "/com.ql.api.Api/GetEnvById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEnvByIdRequest) => Buffer.from(GetEnvByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetEnvByIdRequest.decode(value),
    responseSerialize: (value: EnvResponse) => Buffer.from(EnvResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => EnvResponse.decode(value),
  },
  systemNotify: {
    path: "/com.ql.api.Api/SystemNotify",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SystemNotifyRequest) => Buffer.from(SystemNotifyRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SystemNotifyRequest.decode(value),
    responseSerialize: (value: Response) => Buffer.from(Response.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Response.decode(value),
  },
  getCronDetail: {
    path: "/com.ql.api.Api/GetCronDetail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CronDetailRequest) => Buffer.from(CronDetailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CronDetailRequest.decode(value),
    responseSerialize: (value: CronDetailResponse) => Buffer.from(CronDetailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CronDetailResponse.decode(value),
  },
  createCron: {
    path: "/com.ql.api.Api/CreateCron",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCronRequest) => Buffer.from(CreateCronRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateCronRequest.decode(value),
    responseSerialize: (value: CronResponse) => Buffer.from(CronResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CronResponse.decode(value),
  },
  updateCron: {
    path: "/com.ql.api.Api/UpdateCron",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCronRequest) => Buffer.from(UpdateCronRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateCronRequest.decode(value),
    responseSerialize: (value: CronResponse) => Buffer.from(CronResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CronResponse.decode(value),
  },
  deleteCrons: {
    path: "/com.ql.api.Api/DeleteCrons",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCronsRequest) => Buffer.from(DeleteCronsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteCronsRequest.decode(value),
    responseSerialize: (value: Response) => Buffer.from(Response.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Response.decode(value),
  },
} as const;

export interface ApiServer extends UntypedServiceImplementation {
  getEnvs: handleUnaryCall<GetEnvsRequest, EnvsResponse>;
  createEnv: handleUnaryCall<CreateEnvRequest, EnvsResponse>;
  updateEnv: handleUnaryCall<UpdateEnvRequest, EnvResponse>;
  deleteEnvs: handleUnaryCall<DeleteEnvsRequest, Response>;
  moveEnv: handleUnaryCall<MoveEnvRequest, EnvResponse>;
  disableEnvs: handleUnaryCall<DisableEnvsRequest, Response>;
  enableEnvs: handleUnaryCall<EnableEnvsRequest, Response>;
  updateEnvNames: handleUnaryCall<UpdateEnvNamesRequest, Response>;
  getEnvById: handleUnaryCall<GetEnvByIdRequest, EnvResponse>;
  systemNotify: handleUnaryCall<SystemNotifyRequest, Response>;
  getCronDetail: handleUnaryCall<CronDetailRequest, CronDetailResponse>;
  createCron: handleUnaryCall<CreateCronRequest, CronResponse>;
  updateCron: handleUnaryCall<UpdateCronRequest, CronResponse>;
  deleteCrons: handleUnaryCall<DeleteCronsRequest, Response>;
}

export interface ApiClient extends Client {
  getEnvs(
    request: GetEnvsRequest,
    callback: (error: ServiceError | null, response: EnvsResponse) => void,
  ): ClientUnaryCall;
  getEnvs(
    request: GetEnvsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EnvsResponse) => void,
  ): ClientUnaryCall;
  getEnvs(
    request: GetEnvsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EnvsResponse) => void,
  ): ClientUnaryCall;
  createEnv(
    request: CreateEnvRequest,
    callback: (error: ServiceError | null, response: EnvsResponse) => void,
  ): ClientUnaryCall;
  createEnv(
    request: CreateEnvRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EnvsResponse) => void,
  ): ClientUnaryCall;
  createEnv(
    request: CreateEnvRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EnvsResponse) => void,
  ): ClientUnaryCall;
  updateEnv(
    request: UpdateEnvRequest,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  updateEnv(
    request: UpdateEnvRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  updateEnv(
    request: UpdateEnvRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  deleteEnvs(
    request: DeleteEnvsRequest,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  deleteEnvs(
    request: DeleteEnvsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  deleteEnvs(
    request: DeleteEnvsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  moveEnv(
    request: MoveEnvRequest,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  moveEnv(
    request: MoveEnvRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  moveEnv(
    request: MoveEnvRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  disableEnvs(
    request: DisableEnvsRequest,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  disableEnvs(
    request: DisableEnvsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  disableEnvs(
    request: DisableEnvsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  enableEnvs(
    request: EnableEnvsRequest,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  enableEnvs(
    request: EnableEnvsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  enableEnvs(
    request: EnableEnvsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  updateEnvNames(
    request: UpdateEnvNamesRequest,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  updateEnvNames(
    request: UpdateEnvNamesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  updateEnvNames(
    request: UpdateEnvNamesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  getEnvById(
    request: GetEnvByIdRequest,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  getEnvById(
    request: GetEnvByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  getEnvById(
    request: GetEnvByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EnvResponse) => void,
  ): ClientUnaryCall;
  systemNotify(
    request: SystemNotifyRequest,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  systemNotify(
    request: SystemNotifyRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  systemNotify(
    request: SystemNotifyRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  getCronDetail(
    request: CronDetailRequest,
    callback: (error: ServiceError | null, response: CronDetailResponse) => void,
  ): ClientUnaryCall;
  getCronDetail(
    request: CronDetailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CronDetailResponse) => void,
  ): ClientUnaryCall;
  getCronDetail(
    request: CronDetailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CronDetailResponse) => void,
  ): ClientUnaryCall;
  createCron(
    request: CreateCronRequest,
    callback: (error: ServiceError | null, response: CronResponse) => void,
  ): ClientUnaryCall;
  createCron(
    request: CreateCronRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CronResponse) => void,
  ): ClientUnaryCall;
  createCron(
    request: CreateCronRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CronResponse) => void,
  ): ClientUnaryCall;
  updateCron(
    request: UpdateCronRequest,
    callback: (error: ServiceError | null, response: CronResponse) => void,
  ): ClientUnaryCall;
  updateCron(
    request: UpdateCronRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CronResponse) => void,
  ): ClientUnaryCall;
  updateCron(
    request: UpdateCronRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CronResponse) => void,
  ): ClientUnaryCall;
  deleteCrons(
    request: DeleteCronsRequest,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  deleteCrons(
    request: DeleteCronsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
  deleteCrons(
    request: DeleteCronsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall;
}

export const ApiClient = makeGenericClientConstructor(ApiService, "com.ql.api.Api") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ApiClient;
  service: typeof ApiService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
